# FamilyChain Web3æ ‡å‡†åŒ–ä¼˜åŒ–æŒ‡å—

## ğŸ“‹ ä¼˜åŒ–æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºWeb3è¡Œä¸šæ ‡å‡†å’Œæœ€ä½³å®è·µï¼Œå¯¹FamilyChainé¡¹ç›®è¿›è¡Œæ·±åº¦åˆ†æå’Œä¼˜åŒ–å»ºè®®ã€‚æ—¨åœ¨å¸®åŠ©é¡¹ç›®ä»åŸºç¡€Web3åº”ç”¨æ¼”è¿›ä¸ºç¬¦åˆè¡Œä¸šæ ‡å‡†çš„å®Œæ•´å»ä¸­å¿ƒåŒ–ç”Ÿæ€ç³»ç»Ÿã€‚

## ğŸ¯ æ ¸å¿ƒä¼˜åŒ–ç›®æ ‡

### 1. æå‡å»ä¸­å¿ƒåŒ–ç¨‹åº¦
- æ¶ˆé™¤å•ç‚¹æ•…éšœ
- å‡å°‘å¯¹ä¼ ç»ŸåŸºç¡€è®¾æ–½çš„ä¾èµ–
- å¢å¼ºæŠ—å®¡æŸ¥èƒ½åŠ›

### 2. éµå¾ªWeb3æ ‡å‡†åè®®
- é›†æˆEIPæ ‡å‡†
- æå‡äº’æ“ä½œæ€§
- å¢å¼ºç”Ÿæ€å…¼å®¹æ€§

### 3. ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ
- é™ä½ä½¿ç”¨é—¨æ§›
- æå‡äº¤æ˜“æ•ˆç‡
- å¢å¼ºéšç§ä¿æŠ¤

## ğŸ—ï¸ æ¶æ„ä¼˜åŒ–æ–¹æ¡ˆ

### åŸå§‹æ¶æ„é—®é¢˜åˆ†æ

**å½“å‰æ¶æ„å±€é™æ€§**ï¼š
```
âŒ ä¸­å¿ƒåŒ–åç«¯API (å•ç‚¹æ•…éšœ)
âŒ ä¼ ç»Ÿæ•°æ®åº“ä¾èµ– (éå»ä¸­å¿ƒåŒ–)
âŒ JWTè®¤è¯ä¾èµ–æœåŠ¡å™¨çŠ¶æ€
âŒ æœ‰é™çš„Web3æ ‡å‡†é›†æˆ
```

### æ ‡å‡†åŒ–ä¼˜åŒ–æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Web3æ ‡å‡†åŒ–æ¶æ„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   å‰ç«¯å±‚        â”‚   å»ä¸­å¿ƒåŒ–å­˜å‚¨   â”‚   æ™ºèƒ½åˆçº¦å±‚        â”‚
â”‚                 â”‚                 â”‚                     â”‚
â”‚ React + TS      â”‚ IPFS            â”‚ æ¨¡å—åŒ–åˆçº¦ç³»ç»Ÿ      â”‚
â”‚ RainbowKit      â”‚ â”œâ”€ å…ƒæ•°æ®å­˜å‚¨   â”‚ â”œâ”€ TaskRegistry     â”‚
â”‚ Wagmi + Viem    â”‚ â”œâ”€ å›¾ç‰‡èµ„æº     â”‚ â”œâ”€ RewardSystem     â”‚
â”‚ Web3Modal      â”‚ â””â”€ é…ç½®æ–‡ä»¶     â”‚ â”œâ”€ GovernanceDAO    â”‚
â”‚                 â”‚                 â”‚ â””â”€ UpgradeProxy     â”‚
â”‚ The Graph       â”‚ Arweave         â”‚                     â”‚
â”‚ â”œâ”€ æ•°æ®ç´¢å¼•     â”‚ â”œâ”€ æ°¸ä¹…å­˜å‚¨     â”‚ è·¨é“¾é›†æˆ            â”‚
â”‚ â”œâ”€ æŸ¥è¯¢API      â”‚ â””â”€ å†å²å½’æ¡£     â”‚ â”œâ”€ LayerZero        â”‚
â”‚ â””â”€ å®æ—¶æ›´æ–°     â”‚                 â”‚ â”œâ”€ Polygon          â”‚
â”‚                 â”‚ ENS             â”‚ â””â”€ Arbitrum         â”‚
â”‚ XMTP            â”‚ â”œâ”€ åŸŸåè§£æ     â”‚                     â”‚
â”‚ â”œâ”€ å»ä¸­å¿ƒåŒ–æ¶ˆæ¯ â”‚ â””â”€ èº«ä»½æ ‡è¯†     â”‚ DeFié›†æˆ            â”‚
â”‚ â””â”€ å®¶åº­é€šä¿¡     â”‚                 â”‚ â”œâ”€ Uniswap V3       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š ä¼˜åŒ–æ–¹æ¡ˆè¯¦è§£

### 1. å»ä¸­å¿ƒåŒ–æ•°æ®å­˜å‚¨ä¼˜åŒ–

#### IPFSå…ƒæ•°æ®æ ‡å‡†åŒ–

**ä»»åŠ¡å…ƒæ•°æ®ç»“æ„** (éµå¾ªEIP-721æ ‡å‡†):
```json
{
  "name": "Clean Room Task",
  "description": "Clean your room before 6 PM today",
  "image": "ipfs://QmTaskImageHash...",
  "attributes": [
    {
      "trait_type": "Difficulty",
      "value": "Medium"
    },
    {
      "trait_type": "Category", 
      "value": "Housework"
    },
    {
      "trait_type": "Estimated_Time",
      "value": "30 minutes"
    },
    {
      "trait_type": "Age_Group",
      "value": "8-12 years"
    }
  ],
  "external_url": "https://familychain.app/task/123",
  "created_by": "0xParentAddress...",
  "reward_amount": "10",
  "reward_token": "FAMILY"
}
```

**æ™ºèƒ½åˆçº¦å­˜å‚¨ä¼˜åŒ–**:
```solidity
contract TaskRegistry {
    struct TaskIndex {
        bytes32 metadataHash;  // IPFSå“ˆå¸Œ
        address creator;
        address assignedTo;
        uint256 timestamp;
        TaskStatus status;
        uint256 rewardAmount;
    }
    
    mapping(uint256 => TaskIndex) public tasks;
    
    event TaskCreated(
        uint256 indexed taskId, 
        bytes32 metadataHash,
        address indexed creator,
        address indexed assignedTo
    );
    
    function createTask(
        bytes32 _metadataHash,
        address _assignedTo,
        uint256 _rewardAmount
    ) external {
        uint256 taskId = ++taskCounter;
        tasks[taskId] = TaskIndex({
            metadataHash: _metadataHash,
            creator: msg.sender,
            assignedTo: _assignedTo,
            timestamp: block.timestamp,
            status: TaskStatus.Created,
            rewardAmount: _rewardAmount
        });
        
        emit TaskCreated(taskId, _metadataHash, msg.sender, _assignedTo);
    }
}
```

### 2. Web3æ ‡å‡†åè®®é›†æˆ

#### EIPæ ‡å‡†é›†æˆçŸ©é˜µ

| æ ‡å‡† | åº”ç”¨åœºæ™¯ | å®ç°ä¼˜å…ˆçº§ | æŠ€æœ¯æ”¶ç›Š |
|------|----------|------------|----------|
| EIP-721 | ä»»åŠ¡æˆå°±NFT | é«˜ | å¯äº¤æ˜“æˆå°±ç³»ç»Ÿ |
| EIP-1155 | å¤šç±»å‹å¥–åŠ±ä»£å¸ | é«˜ | ç»Ÿä¸€ä»£å¸ç®¡ç† |
| EIP-712 | ç±»å‹åŒ–æ•°æ®ç­¾å | ä¸­ | å¢å¼ºå®‰å…¨æ€§ |
| EIP-2981 | NFTç‰ˆç¨æ ‡å‡† | ä¸­ | å¯æŒç»­æ”¶ç›Š |
| EIP-4626 | ä»£å¸é‡‘åº“æ ‡å‡† | ä½ | DeFiå…¼å®¹æ€§ |

#### æ ¸å¿ƒåˆçº¦å®ç°

**å¤šç±»å‹å¥–åŠ±ç³»ç»Ÿ** (EIP-1155):
```solidity
contract FamilyRewards is ERC1155, AccessControl {
    // ä»£å¸ç±»å‹å®šä¹‰
    uint256 public constant XP_TOKEN = 1;        // ç»éªŒå€¼ä»£å¸
    uint256 public constant FAMILY_TOKEN = 2;    // å®¶åº­ä»£å¸
    uint256 public constant ACHIEVEMENT_BASE = 1000; // æˆå°±NFTèµ·å§‹ID
    
    mapping(uint256 => string) private _tokenURIs;
    
    function mintReward(
        address to,
        uint256 tokenType,
        uint256 amount,
        bytes memory data
    ) external onlyRole(MINTER_ROLE) {
        _mint(to, tokenType, amount, data);
    }
    
    function mintAchievement(
        address to,
        uint256 achievementId,
        string memory tokenURI
    ) external onlyRole(MINTER_ROLE) {
        uint256 tokenId = ACHIEVEMENT_BASE + achievementId;
        _mint(to, tokenId, 1, "");
        _setTokenURI(tokenId, tokenURI);
    }
}
```

**å»ä¸­å¿ƒåŒ–èº«ä»½è®¤è¯** (EIP-712):
```solidity
contract SignatureAuth {
    bytes32 private constant DOMAIN_TYPEHASH = 
        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    
    bytes32 private constant TASK_COMPLETION_TYPEHASH = 
        keccak256("TaskCompletion(uint256 taskId,address child,uint256 deadline,uint256 nonce)");
    
    mapping(address => uint256) public nonces;
    
    function verifyTaskCompletion(
        uint256 taskId,
        address child,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external view returns (bool) {
        bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(
                TASK_COMPLETION_TYPEHASH,
                taskId,
                child,
                deadline,
                nonces[child]
            ))
        ));
        
        address recoveredAddress = ecrecover(digest, v, r, s);
        return recoveredAddress == child && block.timestamp <= deadline;
    }
}
```

### 3. ä»£å¸ç»æµå­¦ä¼˜åŒ–è®¾è®¡

#### å¤šå±‚ä»£å¸æ¶æ„

```solidity
contract FamilyEcosystem {
    // ç¬¬ä¸€å±‚ï¼šçµé­‚ç»‘å®šç»éªŒä»£å¸ (Soulbound)
    IERC721 public soulboundXP;
    
    // ç¬¬äºŒå±‚ï¼šå®¶åº­æ²»ç†ä»£å¸ (å¯è½¬è®©ï¼Œæœ‰æŠ•ç¥¨æƒ)
    IERC20 public governanceToken;
    
    // ç¬¬ä¸‰å±‚ï¼šå¥–åŠ±ä»£å¸ (å¯äº¤æ˜“)
    IERC20 public rewardToken;
    
    // ä»£å¸è½¬æ¢æœºåˆ¶
    mapping(address => uint256) public xpBalance;
    mapping(address => uint256) public stakingMultiplier;
    
    // å‚æ•°é…ç½®
    uint256 public constant XP_TO_GOVERNANCE_RATIO = 100;  // 100 XP = 1 æ²»ç†ä»£å¸
    uint256 public constant GOVERNANCE_UNLOCK_THRESHOLD = 1000; // è§£é”æ²»ç†æƒé™é˜ˆå€¼
    uint256 public constant BURN_RATE = 5; // 5%é”€æ¯ç‡
    
    function convertXPToGovernance(uint256 xpAmount) external {
        require(xpBalance[msg.sender] >= xpAmount, "Insufficient XP");
        require(xpAmount >= XP_TO_GOVERNANCE_RATIO, "Minimum conversion amount");
        
        uint256 governanceAmount = xpAmount / XP_TO_GOVERNANCE_RATIO;
        xpBalance[msg.sender] -= xpAmount;
        
        governanceToken.mint(msg.sender, governanceAmount);
        
        emit XPConverted(msg.sender, xpAmount, governanceAmount);
    }
    
    // Stakingæœºåˆ¶
    function stakeGovernanceTokens(uint256 amount, uint256 lockPeriod) external {
        require(lockPeriod >= 30 days, "Minimum lock period is 30 days");
        
        governanceToken.transferFrom(msg.sender, address(this), amount);
        
        // é”å®šæ—¶é—´è¶Šé•¿ï¼Œä¹˜æ•°è¶Šé«˜ (1x-3x)
        uint256 multiplier = 1 + (lockPeriod / 30 days);
        if (multiplier > 3) multiplier = 3;
        
        stakes[msg.sender] = StakeInfo({
            amount: amount,
            lockTime: block.timestamp + lockPeriod,
            multiplier: multiplier,
            rewardDebt: 0
        });
        
        emit TokensStaked(msg.sender, amount, lockPeriod, multiplier);
    }
}
```

#### DeFiåè®®é›†æˆ

**Uniswap V3æµåŠ¨æ€§æŒ–çŸ¿**:
```solidity
contract FamilyLiquidityMining {
    IUniswapV3Pool public liquidityPool;
    IERC20 public familyToken;
    IERC20 public weth;
    
    struct LiquidityPosition {
        uint256 tokenId;
        uint128 liquidity;
        uint256 rewardDebt;
        uint256 pendingRewards;
    }
    
    mapping(address => LiquidityPosition) public positions;
    
    function addLiquidity(
        uint256 amount0Desired,
        uint256 amount1Desired,
        int24 tickLower,
        int24 tickUpper
    ) external returns (uint256 tokenId, uint128 liquidity) {
        // Uniswap V3 æµåŠ¨æ€§æ·»åŠ é€»è¾‘
        // è‡ªåŠ¨è®¡ç®—LPå¥–åŠ±
    }
    
    function harvestRewards() external {
        LiquidityPosition storage position = positions[msg.sender];
        uint256 rewards = calculatePendingRewards(msg.sender);
        
        if (rewards > 0) {
            familyToken.mint(msg.sender, rewards);
            position.rewardDebt = position.rewardDebt + rewards;
            
            emit RewardsHarvested(msg.sender, rewards);
        }
    }
}
```

### 4. DAOæ²»ç†ä¸å¯å‡çº§æ€§è®¾è®¡

#### æ ‡å‡†åŒ–DAOæ¶æ„

```solidity
// ä½¿ç”¨OpenZeppelin Governoræ ‡å‡†
contract FamilyDAO is 
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl
{
    constructor(
        IVotes _token,
        TimelockController _timelock
    )
        Governor("FamilyDAO")
        GovernorSettings(1, 50400, 0) // 1 block, 1 week, 0 proposal threshold
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(4) // 4% quorum
        GovernorTimelockControl(_timelock)
    {}
    
    // ææ¡ˆç±»å‹æšä¸¾
    enum ProposalType {
        PARAMETER_CHANGE,     // ç³»ç»Ÿå‚æ•°è°ƒæ•´
        REWARD_ADJUSTMENT,    // å¥–åŠ±æœºåˆ¶è°ƒæ•´
        PROTOCOL_UPGRADE,     // åè®®å‡çº§
        TREASURY_ALLOCATION,  // èµ„é‡‘åˆ†é…
        EMERGENCY_ACTION      // ç´§æ€¥æ“ä½œ
    }
    
    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description,
        ProposalType proposalType
    ) public override returns (uint256) {
        // ä¸åŒç±»å‹ææ¡ˆçš„æƒé™æ£€æŸ¥
        if (proposalType == ProposalType.EMERGENCY_ACTION) {
            require(hasRole(EMERGENCY_ROLE, msg.sender), "Emergency role required");
        }
        
        return super.propose(targets, values, calldatas, description);
    }
    
    // æŠ•ç¥¨æƒé‡è®¡ç®— (è€ƒè™‘StakingåŠ æˆ)
    function _getVotes(
        address account,
        uint256 blockNumber,
        bytes memory params
    ) internal view override returns (uint256) {
        uint256 baseVotes = super._getVotes(account, blockNumber, params);
        uint256 stakingMultiplier = getStakingMultiplier(account);
        
        return baseVotes * stakingMultiplier / 100; // ç™¾åˆ†æ¯”åˆ¶
    }
}
```

#### æ¨¡å—åŒ–å‡çº§ç³»ç»Ÿ

```solidity
contract ModularUpgradeSystem {
    using EnumerableSet for EnumerableSet.Bytes32Set;
    
    // æ¨¡å—æ³¨å†Œè¡¨
    mapping(bytes32 => address) public modules;
    mapping(bytes32 => uint256) public moduleVersions;
    EnumerableSet.Bytes32Set private moduleIds;
    
    // æ¨¡å—ç±»å‹
    bytes32 public constant TASK_MODULE = keccak256("TASK_MODULE");
    bytes32 public constant REWARD_MODULE = keccak256("REWARD_MODULE");
    bytes32 public constant GOVERNANCE_MODULE = keccak256("GOVERNANCE_MODULE");
    
    event ModuleUpgraded(
        bytes32 indexed moduleId,
        address oldImplementation,
        address newImplementation,
        uint256 version
    );
    
    function upgradeModule(
        bytes32 moduleId,
        address newImplementation
    ) external onlyGovernance {
        require(moduleIds.contains(moduleId), "Module not registered");
        
        address oldImplementation = modules[moduleId];
        modules[moduleId] = newImplementation;
        moduleVersions[moduleId]++;
        
        emit ModuleUpgraded(
            moduleId,
            oldImplementation,
            newImplementation,
            moduleVersions[moduleId]
        );
    }
    
    function registerModule(
        bytes32 moduleId,
        address implementation
    ) external onlyGovernance {
        require(!moduleIds.contains(moduleId), "Module already exists");
        
        modules[moduleId] = implementation;
        moduleVersions[moduleId] = 1;
        moduleIds.add(moduleId);
        
        emit ModuleRegistered(moduleId, implementation);
    }
}
```

### 5. è·¨é“¾ç”Ÿæ€æ‰©å±•

#### LayerZeroè·¨é“¾æ¡¥é›†æˆ

```solidity
contract CrossChainFamily is NonblockingLzApp {
    using BytesLib for bytes;
    
    // æ”¯æŒçš„é“¾ID
    uint16 public constant ETHEREUM_CHAIN_ID = 101;
    uint16 public constant POLYGON_CHAIN_ID = 109;
    uint16 public constant ARBITRUM_CHAIN_ID = 110;
    
    // è·¨é“¾æ¶ˆæ¯ç±»å‹
    uint16 public constant PT_TASK_COMPLETION = 1;
    uint16 public constant PT_REWARD_CLAIM = 2;
    uint16 public constant PT_FAMILY_SYNC = 3;
    
    mapping(uint16 => address) public trustedRemotes;
    mapping(address => mapping(uint16 => uint256)) public userNonces;
    
    function sendTaskCompletion(
        uint16 _dstChainId,
        address _child,
        uint256 _taskId,
        uint256 _rewardAmount
    ) external payable {
        require(trustedRemotes[_dstChainId] != address(0), "Untrusted remote");
        
        bytes memory payload = abi.encode(
            PT_TASK_COMPLETION,
            _child,
            _taskId,
            _rewardAmount,
            userNonces[_child][_dstChainId]++
        );
        
        _lzSend(
            _dstChainId,
            payload,
            payable(msg.sender),
            address(0),
            bytes(""),
            msg.value
        );
        
        emit TaskCompletionSent(_dstChainId, _child, _taskId, _rewardAmount);
    }
    
    function _nonblockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        uint16 packetType = _payload.toUint16(0);
        
        if (packetType == PT_TASK_COMPLETION) {
            _handleTaskCompletion(_srcChainId, _payload);
        } else if (packetType == PT_REWARD_CLAIM) {
            _handleRewardClaim(_srcChainId, _payload);
        } else if (packetType == PT_FAMILY_SYNC) {
            _handleFamilySync(_srcChainId, _payload);
        }
    }
    
    function _handleTaskCompletion(
        uint16 _srcChainId,
        bytes memory _payload
    ) internal {
        (, address child, uint256 taskId, uint256 rewardAmount, uint256 nonce) = 
            abi.decode(_payload, (uint16, address, uint256, uint256, uint256));
        
        // éªŒè¯nonceé˜²é‡æ”¾
        require(nonce == userNonces[child][_srcChainId], "Invalid nonce");
        userNonces[child][_srcChainId]++;
        
        // åœ¨æœ¬é“¾é“¸é€ å¥–åŠ±
        rewardToken.mint(child, rewardAmount);
        
        emit CrossChainTaskCompleted(_srcChainId, child, taskId, rewardAmount);
    }
}
```

#### å¤šé“¾éƒ¨ç½²é…ç½®

```solidity
contract MultiChainDeployer {
    struct ChainConfig {
        uint256 chainId;
        address wrappedNative;
        address uniswapRouter;
        address multicall;
        uint256 blockTime;
        uint256 gasLimit;
    }
    
    mapping(uint256 => ChainConfig) public chainConfigs;
    mapping(uint256 => address) public deployedContracts;
    
    function deployOnChain(uint256 chainId) external onlyOwner {
        ChainConfig memory config = chainConfigs[chainId];
        require(config.chainId != 0, "Chain not configured");
        
        // éƒ¨ç½²æ ¸å¿ƒåˆçº¦
        address taskRegistry = deployTaskRegistry(config);
        address rewardSystem = deployRewardSystem(config);
        address governance = deployGovernance(config);
        
        deployedContracts[chainId] = taskRegistry;
        
        emit ContractsDeployed(chainId, taskRegistry, rewardSystem, governance);
    }
    
    function configureChain(
        uint256 chainId,
        address wrappedNative,
        address uniswapRouter,
        address multicall,
        uint256 blockTime,
        uint256 gasLimit
    ) external onlyOwner {
        chainConfigs[chainId] = ChainConfig({
            chainId: chainId,
            wrappedNative: wrappedNative,
            uniswapRouter: uniswapRouter,
            multicall: multicall,
            blockTime: blockTime,
            gasLimit: gasLimit
        });
        
        emit ChainConfigured(chainId);
    }
}
```

### 6. éšç§ä¿æŠ¤å¢å¼º

#### é›¶çŸ¥è¯†è¯æ˜ä»»åŠ¡éªŒè¯

```solidity
contract ZKTaskVerification {
    using Verifier for bytes32;
    
    struct ZKProof {
        uint256[2] a;
        uint256[2][2] b;
        uint256[2] c;
    }
    
    mapping(uint256 => bytes32) public taskCommitments;
    mapping(address => uint256) public userNonces;
    
    // ç”Ÿæˆä»»åŠ¡æ‰¿è¯º (éšè—ä»»åŠ¡ç»†èŠ‚)
    function commitTask(
        bytes32 commitment
    ) external returns (uint256 taskId) {
        taskId = ++taskCounter;
        taskCommitments[taskId] = commitment;
        
        emit TaskCommitted(taskId, msg.sender, commitment);
    }
    
    // é›¶çŸ¥è¯†è¯æ˜ä»»åŠ¡å®Œæˆ
    function proveTaskCompletion(
        uint256 taskId,
        ZKProof memory proof,
        uint256[] memory publicInputs
    ) external {
        require(taskCommitments[taskId] != bytes32(0), "Task not found");
        
        // éªŒè¯ZKè¯æ˜
        bool isValid = verifyProof(
            proof.a,
            proof.b,
            proof.c,
            publicInputs
        );
        
        require(isValid, "Invalid proof");
        
        // å‘æ”¾å¥–åŠ±è€Œä¸æš´éœ²ä»»åŠ¡å…·ä½“å†…å®¹
        _mintReward(msg.sender, taskId);
        
        emit TaskCompletedPrivately(taskId, msg.sender);
    }
    
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory input
    ) internal pure returns (bool) {
        // Groth16 éªŒè¯é€»è¾‘
        // ä½¿ç”¨circomlibç”Ÿæˆçš„éªŒè¯å™¨
        return true; // ç®€åŒ–å®ç°
    }
}
```

### 7. ç¤¾äº¤åŠŸèƒ½Web3åŒ–

#### Lens Protocolé›†æˆ

```solidity
contract FamilyLensIntegration {
    ILensHub public lensHub;
    
    struct FamilyProfile {
        uint256 lensProfileId;
        string familyName;
        address[] members;
        uint256 totalTasks;
        uint256 totalRewards;
    }
    
    mapping(address => FamilyProfile) public familyProfiles;
    
    function createFamilyProfile(
        string memory familyName,
        string memory profileImageURI
    ) external {
        // åœ¨Lensä¸Šåˆ›å»ºå®¶åº­æ¡£æ¡ˆ
        uint256 profileId = lensHub.createProfile(
            msg.sender,
            familyName,
            profileImageURI,
            address(0), // followModule
            bytes(""), // followModuleInitData
            "" // followNFTURI
        );
        
        familyProfiles[msg.sender] = FamilyProfile({
            lensProfileId: profileId,
            familyName: familyName,
            members: new address[](0),
            totalTasks: 0,
            totalRewards: 0
        });
        
        emit FamilyProfileCreated(msg.sender, profileId, familyName);
    }
    
    function publishTaskCompletion(
        uint256 taskId,
        string memory description
    ) external {
        FamilyProfile storage profile = familyProfiles[msg.sender];
        require(profile.lensProfileId != 0, "Profile not found");
        
        // å‘å¸ƒåˆ°Lensç¤¾äº¤å›¾è°±
        lensHub.post(
            profile.lensProfileId,
            description,
            address(0), // collectModule
            bytes(""), // collectModuleInitData
            address(0), // referenceModule
            bytes("") // referenceModuleInitData
        );
        
        emit TaskSharedOnLens(msg.sender, taskId, profile.lensProfileId);
    }
}
```

#### XMTPå»ä¸­å¿ƒåŒ–æ¶ˆæ¯ç³»ç»Ÿ

```typescript
// å‰ç«¯é›†æˆXMTP
import { Client } from '@xmtp/xmtp-js'

class FamilyMessaging {
    private xmtpClient: Client | null = null;
    
    async initializeMessaging(signer: Signer) {
        this.xmtpClient = await Client.create(signer, { env: 'production' });
    }
    
    async sendTaskNotification(
        recipientAddress: string,
        taskData: {
            id: number;
            title: string;
            description: string;
            dueDate: Date;
            reward: string;
        }
    ) {
        if (!this.xmtpClient) throw new Error('XMTP client not initialized');
        
        const conversation = await this.xmtpClient.conversations.newConversation(
            recipientAddress
        );
        
        const message = {
            type: 'task_notification',
            data: taskData,
            timestamp: Date.now(),
            version: '1.0'
        };
        
        await conversation.send(JSON.stringify(message));
    }
    
    async listenForMessages(onMessage: (message: any) => void) {
        if (!this.xmtpClient) return;
        
        for await (const message of await this.xmtpClient.conversations.streamAllMessages()) {
            try {
                const parsedMessage = JSON.parse(message.content);
                if (parsedMessage.type === 'task_notification') {
                    onMessage(parsedMessage);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        }
    }
}
```

## ğŸ“ åˆå­¦è€…ä¼˜åŒ–æ€è·¯æŒ‡å¯¼

### ğŸ’¡ å¦‚ä½•æ€è€ƒWeb3é¡¹ç›®ä¼˜åŒ–

#### 1. å»ä¸­å¿ƒåŒ–æ€ç»´æ¨¡å¼

**ä»ä¼ ç»Ÿåº”ç”¨åˆ°Web3çš„æ€ç»´è½¬å˜**ï¼š

| ä¼ ç»ŸWeb2æ€ç»´ | Web3å»ä¸­å¿ƒåŒ–æ€ç»´ | ä¼˜åŒ–å»ºè®® |
|-------------|-----------------|----------|
| "ç”¨æˆ·ç™»å½•è´¦å·å¯†ç " | "ç”¨æˆ·è¿æ¥é’±åŒ…åœ°å€" | å®ç°é’±åŒ…èº«ä»½è®¤è¯ |
| "æ•°æ®å­˜å‚¨åœ¨æ•°æ®åº“" | "æ•°æ®å­˜å‚¨åœ¨åŒºå—é“¾+IPFS" | æ··åˆå­˜å‚¨æ¶æ„ |
| "æœåŠ¡å™¨å¤„ç†ä¸šåŠ¡é€»è¾‘" | "æ™ºèƒ½åˆçº¦å¤„ç†æ ¸å¿ƒé€»è¾‘" | é“¾ä¸Šé“¾ä¸‹èŒè´£åˆ†ç¦» |
| "ä¸­å¿ƒåŒ–APIæœåŠ¡" | "å»ä¸­å¿ƒåŒ–æŸ¥è¯¢åè®®" | ä½¿ç”¨The Graphç­‰ |
| "å…¬å¸æ‹¥æœ‰å¹³å°æ§åˆ¶æƒ" | "ç¤¾åŒºé€šè¿‡DAOæ²»ç†" | æ¸è¿›å¼å»ä¸­å¿ƒåŒ– |

**åˆå­¦è€…å¸¸è§è¯¯åŒº**ï¼š
```typescript
// âŒ é”™è¯¯ï¼šä»ç„¶ä¾èµ–ä¸­å¿ƒåŒ–æ€ç»´
const saveUserData = async (userData) => {
  const response = await fetch('/api/users', {
    method: 'POST',
    body: JSON.stringify(userData)
  });
  return response.json();
};

// âœ… æ­£ç¡®ï¼šWeb3å»ä¸­å¿ƒåŒ–æ€ç»´
const saveUserDataWeb3 = async (userData, signer) => {
  // 1. æ•æ„Ÿæ•°æ®å­˜å‚¨åˆ°IPFS
  const metadataHash = await uploadToIPFS(userData);
  
  // 2. å…³é”®ä¿¡æ¯ä¸Šé“¾å­˜å‚¨
  const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
  const tx = await contract.updateUserData(metadataHash);
  
  // 3. ç­‰å¾…äº¤æ˜“ç¡®è®¤
  await tx.wait();
  return metadataHash;
};
```

#### 2. æ ‡å‡†åŒ–é›†æˆæ€è€ƒæ¡†æ¶

**EIPæ ‡å‡†é€‰æ‹©å†³ç­–æ ‘**ï¼š
```
æ‚¨çš„é¡¹ç›®éœ€è¦ä»€ä¹ˆåŠŸèƒ½ï¼Ÿ
â”œâ”€ éœ€è¦NFTï¼Ÿ
â”‚  â”œâ”€ å•ä¸€ç±»å‹ â†’ EIP-721
â”‚  â””â”€ å¤šç§ç±»å‹ â†’ EIP-1155
â”œâ”€ éœ€è¦ä»£å¸ï¼Ÿ
â”‚  â”œâ”€ æ²»ç†ä»£å¸ â†’ EIP-20 + EIP-2612
â”‚  â””â”€ å®ç”¨ä»£å¸ â†’ EIP-20
â”œâ”€ éœ€è¦èº«ä»½éªŒè¯ï¼Ÿ
â”‚  â””â”€ æ¶ˆæ¯ç­¾å â†’ EIP-712
â”œâ”€ éœ€è¦ç‰ˆç¨æ”¶å…¥ï¼Ÿ
â”‚  â””â”€ NFTç‰ˆç¨ â†’ EIP-2981
â””â”€ éœ€è¦DeFié›†æˆï¼Ÿ
   â””â”€ èµ„äº§ç®¡ç† â†’ EIP-4626
```

**æ ‡å‡†åŒ–æ€è€ƒæµç¨‹**ï¼š
1. **åˆ†ææ ¸å¿ƒä¸šåŠ¡** â†’ ç¡®å®šéœ€è¦å“ªäº›Web3åŠŸèƒ½
2. **æŸ¥æ‰¾ç›¸å…³EIP** â†’ é¿å…é‡æ–°å‘æ˜è½®å­
3. **è¯„ä¼°å…¼å®¹æ€§** â†’ ç¡®ä¿ä¸ç°æœ‰ç”Ÿæ€å…¼å®¹
4. **æ¸è¿›å¼é›†æˆ** â†’ ä»æ ¸å¿ƒåŠŸèƒ½å¼€å§‹ï¼Œé€æ­¥æ‰©å±•

#### 3. æ¶æ„è®¾è®¡åŸåˆ™

**Web3æ¶æ„è®¾è®¡çš„ä¸‰å±‚æ€è€ƒ**ï¼š

```
ç¬¬ä¸€å±‚ï¼šæ ¸å¿ƒä»·å€¼å±‚ï¼ˆå¿…é¡»å»ä¸­å¿ƒåŒ–ï¼‰
â”œâ”€ èµ„äº§æ‰€æœ‰æƒ â†’ æ™ºèƒ½åˆçº¦ç®¡ç†
â”œâ”€ å…³é”®ä¸šåŠ¡é€»è¾‘ â†’ é“¾ä¸Šæ‰§è¡Œ
â””â”€ æ²»ç†å†³ç­– â†’ DAOæŠ•ç¥¨

ç¬¬äºŒå±‚ï¼šæ•°æ®å±‚ï¼ˆæ··åˆæ–¹æ¡ˆï¼‰
â”œâ”€ å…³é”®æ•°æ® â†’ é“¾ä¸Šå­˜å‚¨
â”œâ”€ å…ƒæ•°æ® â†’ IPFSå­˜å‚¨
â””â”€ æŸ¥è¯¢ç´¢å¼• â†’ The Graph

ç¬¬ä¸‰å±‚ï¼šç”¨æˆ·ä½“éªŒå±‚ï¼ˆå¯é€‚åº¦ä¸­å¿ƒåŒ–ï¼‰
â”œâ”€ ç•Œé¢æ¸²æŸ“ â†’ ä¼ ç»Ÿå‰ç«¯
â”œâ”€ å®æ—¶é€šçŸ¥ â†’ æ¨é€æœåŠ¡
â””â”€ æ€§èƒ½ä¼˜åŒ– â†’ CDNåŠ é€Ÿ
```

**åˆå­¦è€…å®ç”¨æ–¹æ³•**ï¼š

1. **"æœ€å°å¯è¡Œå»ä¸­å¿ƒåŒ–"åŸåˆ™**
   ```solidity
   // ä»ç®€å•å¼€å§‹ï¼Œé€æ­¥å¢å¼º
   contract SimpleTaskRegistry {
       mapping(uint256 => Task) public tasks;
       
       function createTask(string memory title) external {
           // å…ˆå®ç°åŸºæœ¬åŠŸèƒ½
           tasks[nextTaskId] = Task(title, msg.sender, block.timestamp);
           nextTaskId++;
       }
   }
   
   // åç»­è¿­ä»£å¢åŠ å¤æ‚åŠŸèƒ½
   contract AdvancedTaskRegistry is SimpleTaskRegistry {
       function createTaskWithMetadata(bytes32 ipfsHash) external {
           // é›†æˆIPFSå…ƒæ•°æ®
       }
   }
   ```

2. **"æ¸è¿›å¼æ ‡å‡†åŒ–"ç­–ç•¥**
   ```typescript
   // Phase 1: åŸºç¡€åŠŸèƒ½
   const createTask = async (title: string) => {
     const tx = await contract.createTask(title);
     return tx.wait();
   };
   
   // Phase 2: æ ‡å‡†åŒ–å…ƒæ•°æ®
   const createTaskWithMetadata = async (taskData: TaskMetadata) => {
     const ipfsHash = await uploadToIPFS(taskData);
     const tx = await contract.createTaskWithMetadata(ipfsHash);
     return tx.wait();
   };
   
   // Phase 3: è·¨é“¾å…¼å®¹
   const createCrossChainTask = async (taskData: TaskMetadata, targetChain: number) => {
     // LayerZeroè·¨é“¾å®ç°
   };
   ```

### ğŸ›  æŠ€æœ¯é€‰å‹æŒ‡å¯¼

#### å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©

| æ•°æ®ç±»å‹ | æ¨èæ–¹æ¡ˆ | ç†ç”± | å®ç°éš¾åº¦ |
|---------|---------|------|---------|
| ç”¨æˆ·èµ„äº§ | æ™ºèƒ½åˆçº¦ | å»ä¸­å¿ƒåŒ–ï¼Œä¸å¯ç¯¡æ”¹ | ä¸­ç­‰ |
| ä»»åŠ¡å…ƒæ•°æ® | IPFS | æˆæœ¬ä½ï¼Œå†…å®¹å¯»å€ | ç®€å• |
| å†å²è®°å½• | Arweave | æ°¸ä¹…å­˜å‚¨ | ç®€å• |
| å®æ—¶æŸ¥è¯¢ | The Graph | é«˜æ€§èƒ½ï¼Œå»ä¸­å¿ƒåŒ– | å¤æ‚ |
| ä¸´æ—¶ç¼“å­˜ | Redis | æ€§èƒ½æœ€ä¼˜ | ç®€å• |

#### ç½‘ç»œé€‰æ‹©æŒ‡å—

```typescript
// ç½‘ç»œé€‰æ‹©å†³ç­–ä»£ç 
const selectNetwork = (requirements: ProjectRequirements) => {
  if (requirements.highSecurity && requirements.budgetHigh) {
    return 'Ethereum Mainnet';
  }
  
  if (requirements.lowCost && requirements.highTPS) {
    return 'Polygon';
  }
  
  if (requirements.lowLatency && requirements.EVM) {
    return 'Arbitrum';
  }
  
  if (requirements.testing) {
    return 'Sepolia';
  }
};
```

#### å‰ç«¯æŠ€æœ¯æ ˆå»ºè®®

**åˆå­¦è€…å‹å¥½çš„æŠ€æœ¯ç»„åˆ**ï¼š

```json
{
  "æ¨èé…ç½®": {
    "æ¡†æ¶": "Next.js + TypeScript",
    "Web3åº“": "Wagmi + Viem",
    "é’±åŒ…é›†æˆ": "RainbowKit",
    "æ ·å¼": "TailwindCSS",
    "çŠ¶æ€ç®¡ç†": "Zustand",
    "è¡¨å•": "React Hook Form",
    "å›¾æ ‡": "Lucide React"
  },
  "å­¦ä¹ è·¯å¾„": [
    "1. æŒæ¡ReactåŸºç¡€",
    "2. å­¦ä¹ TypeScript",
    "3. äº†è§£ä»¥å¤ªåŠåŸºç¡€",
    "4. å®è·µWagmi Hooks",
    "5. é›†æˆé’±åŒ…è¿æ¥",
    "6. å®ç°åˆçº¦äº¤äº’"
  ]
}
```

### ğŸ“ˆ ä¼˜åŒ–å®æ–½è·¯å¾„

#### Phase 1: åŸºç¡€å»ä¸­å¿ƒåŒ–æ”¹é€ ï¼ˆ1-2ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šæ¶ˆé™¤æ ¸å¿ƒä¸šåŠ¡å¯¹åç«¯APIçš„ä¾èµ–

**å®æ–½æ­¥éª¤**ï¼š
1. **é’±åŒ…èº«ä»½è®¤è¯**
   ```typescript
   // æ›¿æ¢JWTè®¤è¯ä¸ºé’±åŒ…ç­¾åè®¤è¯
   const authenticateUser = async (address: string, signature: string) => {
     const message = `Login to FamilyChain: ${Date.now()}`;
     const recoveredAddress = ethers.utils.verifyMessage(message, signature);
     return recoveredAddress.toLowerCase() === address.toLowerCase();
   };
   ```

2. **IPFSå…ƒæ•°æ®å­˜å‚¨**
   ```typescript
   // ä»»åŠ¡å…ƒæ•°æ®ä¸Šä¼ åˆ°IPFS
   const createTaskMetadata = async (taskData: Task) => {
     const metadata = {
       name: taskData.title,
       description: taskData.description,
       attributes: taskData.attributes
     };
     
     const ipfsHash = await ipfs.add(JSON.stringify(metadata));
     return ipfsHash.path;
   };
   ```

3. **The Graphæ•°æ®ç´¢å¼•**
   ```graphql
   # schema.graphql
   type Task @entity {
     id: ID!
     creator: Bytes!
     assignedTo: Bytes!
     metadataHash: String!
     status: TaskStatus!
     createdAt: BigInt!
   }
   ```

#### Phase 2: æ ‡å‡†åè®®é›†æˆï¼ˆ2-3ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå®ç°EIPæ ‡å‡†å…¼å®¹ï¼Œå¢å¼ºäº’æ“ä½œæ€§

**å…³é”®é‡Œç¨‹ç¢‘**ï¼š
- [ ] EIP-721ä»»åŠ¡æˆå°±NFTç³»ç»Ÿ
- [ ] EIP-1155å¤šç±»å‹å¥–åŠ±ä»£å¸
- [ ] EIP-712ç­¾åéªŒè¯
- [ ] EIP-2981ç‰ˆç¨åˆ†é…

#### Phase 3: æ²»ç†å’Œå¯å‡çº§æ€§ï¼ˆ2-3ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå»ºç«‹DAOæ²»ç†æœºåˆ¶å’Œåˆçº¦å‡çº§èƒ½åŠ›

**å®æ–½è¦ç‚¹**ï¼š
- OpenZeppelin Governoré›†æˆ
- Timelockæ§åˆ¶å™¨
- æ¨¡å—åŒ–å‡çº§ç³»ç»Ÿ
- å¤šé‡ç­¾åå®‰å…¨

#### Phase 4: è·¨é“¾å’ŒDeFié›†æˆï¼ˆ3-4ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå®ç°å¤šé“¾éƒ¨ç½²å’ŒDeFiåè®®é›†æˆ

**æŠ€æœ¯é‡ç‚¹**ï¼š
- LayerZeroè·¨é“¾æ¡¥
- Uniswap V3æµåŠ¨æ€§æŒ–çŸ¿
- è·¨é“¾èµ„äº§ç®¡ç†
- æ”¶ç›Šä¼˜åŒ–ç­–ç•¥

#### Phase 5: éšç§å’Œç¤¾äº¤åŠŸèƒ½ï¼ˆ2-3ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå¢å¼ºéšç§ä¿æŠ¤å’Œç¤¾äº¤äº’åŠ¨åŠŸèƒ½

**åˆ›æ–°ç‰¹æ€§**ï¼š
- é›¶çŸ¥è¯†è¯æ˜ä»»åŠ¡éªŒè¯
- Lens Protocolç¤¾äº¤é›†æˆ
- XMTPå»ä¸­å¿ƒåŒ–æ¶ˆæ¯
- å£°èª‰ç³»ç»Ÿå»ºè®¾

### ğŸ”§ å¼€å‘æœ€ä½³å®è·µ

#### 1. åˆçº¦å¼€å‘è§„èŒƒ

```solidity
// ä½¿ç”¨æ ‡å‡†åº“å’Œç»è¿‡å®¡è®¡çš„ä»£ç 
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";

contract TaskNFT is ERC721, AccessControl, UUPSUpgradeable {
    // ä½¿ç”¨å¸¸é‡èŠ‚çœGas
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    
    // ä½¿ç”¨äº‹ä»¶è®°å½•é‡è¦æ“ä½œ
    event TaskCompleted(uint256 indexed taskId, address indexed child);
    
    // å®ç°å®Œæ•´çš„æƒé™æ£€æŸ¥
    function mintTaskNFT(address to, uint256 tokenId) 
        external 
        onlyRole(MINTER_ROLE) 
    {
        require(to != address(0), "Invalid address");
        _mint(to, tokenId);
        emit TaskCompleted(tokenId, to);
    }
    
    // å¿…é¡»å®ç°çš„å‡çº§æˆæƒ
    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyRole(DEFAULT_ADMIN_ROLE)
    {}
}
```

#### 2. å‰ç«¯å¼€å‘æ¨¡å¼

```typescript
// ä½¿ç”¨ç±»å‹å®‰å…¨çš„åˆçº¦äº¤äº’
import { useContractWrite, useWaitForTransaction } from 'wagmi';
import { taskRegistryABI } from '../abis/TaskRegistry';

const useCreateTask = () => {
  const { data, write, error, isLoading } = useContractWrite({
    address: TASK_REGISTRY_ADDRESS,
    abi: taskRegistryABI,
    functionName: 'createTask',
  });

  const { isLoading: isConfirming } = useWaitForTransaction({
    hash: data?.hash,
  });

  return {
    createTask: write,
    isLoading: isLoading || isConfirming,
    error,
    txHash: data?.hash,
  };
};

// é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ
const TaskCreationForm = () => {
  const { createTask, isLoading, error } = useCreateTask();
  
  const handleSubmit = async (taskData: TaskData) => {
    try {
      // 1. ä¸Šä¼ å…ƒæ•°æ®åˆ°IPFS
      const ipfsHash = await uploadToIPFS(taskData);
      
      // 2. è°ƒç”¨æ™ºèƒ½åˆçº¦
      createTask({
        args: [ipfsHash, taskData.assignedTo, taskData.rewardAmount]
      });
      
      // 3. æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
      toast.success('Task created successfully!');
    } catch (err) {
      console.error('Task creation failed:', err);
      toast.error('Failed to create task');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* è¡¨å•å†…å®¹ */}
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Creating...' : 'Create Task'}
      </button>
      {error && <p className="error">{error.message}</p>}
    </form>
  );
};
```

#### 3. æµ‹è¯•ç­–ç•¥

```typescript
// åˆçº¦æµ‹è¯•
describe("TaskRegistry", function () {
  let taskRegistry: TaskRegistry;
  let owner: SignerWithAddress;
  let child: SignerWithAddress;

  beforeEach(async function () {
    [owner, child] = await ethers.getSigners();
    
    const TaskRegistry = await ethers.getContractFactory("TaskRegistry");
    taskRegistry = await TaskRegistry.deploy();
    await taskRegistry.deployed();
  });

  it("Should create task with correct metadata", async function () {
    const ipfsHash = "QmTest123...";
    const rewardAmount = ethers.utils.parseEther("0.1");
    
    await expect(
      taskRegistry.createTask(ipfsHash, child.address, rewardAmount)
    )
      .to.emit(taskRegistry, "TaskCreated")
      .withArgs(1, ipfsHash, owner.address, child.address);
      
    const task = await taskRegistry.tasks(1);
    expect(task.creator).to.equal(owner.address);
    expect(task.assignedTo).to.equal(child.address);
  });
});

// å‰ç«¯é›†æˆæµ‹è¯•
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { TaskCreationForm } from './TaskCreationForm';

test('should create task successfully', async () => {
  render(<TaskCreationForm />);
  
  fireEvent.change(screen.getByLabelText('Task Title'), {
    target: { value: 'Clean Room' }
  });
  
  fireEvent.click(screen.getByText('Create Task'));
  
  await waitFor(() => {
    expect(screen.getByText('Task created successfully!')).toBeInTheDocument();
  });
});
```

### ğŸ“š å­¦ä¹ èµ„æºå’Œç¤¾åŒº

#### å¿…è¯»æ–‡æ¡£å’Œæ•™ç¨‹

**åŸºç¡€çŸ¥è¯†**ï¼š
- [Ethereum.org Developer Portal](https://ethereum.org/developers/)
- [Solidityå®˜æ–¹æ–‡æ¡£](https://docs.soliditylang.org/)
- [OpenZeppelinåˆçº¦åº“](https://docs.openzeppelin.com/)

**Web3å‰ç«¯å¼€å‘**ï¼š
- [Wagmiå®˜æ–¹æ–‡æ¡£](https://wagmi.sh/)
- [RainbowKitæŒ‡å—](https://www.rainbowkit.com/)
- [The Graphæ–‡æ¡£](https://thegraph.com/docs/)

**è¿›é˜¶ä¸»é¢˜**ï¼š
- [EIPå®˜æ–¹è§„èŒƒ](https://eips.ethereum.org/)
- [DeFiå¼€å‘æŒ‡å—](https://defi-learning.org/)
- [DAOæ²»ç†æœ€ä½³å®è·µ](https://gov.gitcoin.co/)

#### å®ç”¨å·¥å…·å’Œå¹³å°

**å¼€å‘å·¥å…·**ï¼š
```bash
# æ™ºèƒ½åˆçº¦å¼€å‘
npm install -D hardhat @openzeppelin/contracts

# å‰ç«¯å¼€å‘
npm install wagmi viem @rainbow-me/rainbowkit

# æµ‹è¯•å·¥å…·
npm install -D @nomicfoundation/hardhat-chai-matchers
```

**åœ¨çº¿èµ„æº**ï¼š
- [Remix IDE](https://remix.ethereum.org/) - åœ¨çº¿Solidityå¼€å‘
- [Tenderly](https://tenderly.co/) - åˆçº¦è°ƒè¯•å’Œç›‘æ§
- [Hardhat Network](https://hardhat.org/) - æœ¬åœ°å¼€å‘ç½‘ç»œ
- [IPFS Desktop](https://github.com/ipfs/ipfs-desktop) - IPFSèŠ‚ç‚¹ç®¡ç†

### ğŸ¯ æˆåŠŸæ ‡å‡†å’Œè¯„ä¼°

#### æŠ€æœ¯æŒ‡æ ‡

| æŒ‡æ ‡ç±»åˆ« | è¯„ä¼°æ ‡å‡† | ç›®æ ‡å€¼ |
|---------|---------|--------|
| å»ä¸­å¿ƒåŒ–ç¨‹åº¦ | æ— å•ç‚¹æ•…éšœç»„ä»¶å æ¯” | >80% |
| æ ‡å‡†å…¼å®¹æ€§ | å®ç°çš„EIPæ ‡å‡†æ•°é‡ | â‰¥5ä¸ª |
| å®‰å…¨æ€§ | é€šè¿‡å®‰å…¨å®¡è®¡é¡¹ç›®æ•° | 100% |
| æ€§èƒ½ | äº¤æ˜“ç¡®è®¤æ—¶é—´ | <15ç§’ |
| æˆæœ¬ | å¹³å‡äº¤æ˜“è´¹ç”¨ | <$0.5 |

#### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡

- **é’±åŒ…è¿æ¥æˆåŠŸç‡** > 95%
- **äº¤æ˜“å¤±è´¥ç‡** < 2%
- **é¡µé¢åŠ è½½æ—¶é—´** < 3ç§’
- **ç§»åŠ¨ç«¯å…¼å®¹æ€§** å®Œå…¨æ”¯æŒ
- **å¤šè¯­è¨€æ”¯æŒ** è‡³å°‘3ç§è¯­è¨€

#### ç”Ÿæ€ç³»ç»Ÿé›†æˆåº¦

- **DeFiåè®®é›†æˆ** è‡³å°‘2ä¸ªä¸»æµåè®®
- **è·¨é“¾æ”¯æŒ** è‡³å°‘3æ¡ä¸»è¦åŒºå—é“¾
- **NFTå¸‚åœºå…¼å®¹** OpenSeaç­‰ä¸»æµå¹³å°
- **DAOå·¥å…·é›†æˆ** Snapshotç­‰æ²»ç†å¹³å°

é€šè¿‡è¿™ä»½æ ‡å‡†åŒ–ä¼˜åŒ–æŒ‡å—ï¼Œåˆå­¦è€…å¯ä»¥ç³»ç»Ÿæ€§åœ°ç†è§£å¦‚ä½•å°†åŸºç¡€Web3é¡¹ç›®æå‡åˆ°ä¼ä¸šçº§æ°´å‡†ï¼ŒåŒæ—¶æŒæ¡è¡Œä¸šæœ€ä½³å®è·µå’Œæ ‡å‡†åŒ–æ–¹æ³•ã€‚è®°ä½ï¼Œä¼˜åŒ–æ˜¯ä¸€ä¸ªæ¸è¿›çš„è¿‡ç¨‹ï¼Œä»æ ¸å¿ƒåŠŸèƒ½å¼€å§‹ï¼Œé€æ­¥æ‰©å±•åˆ°å®Œæ•´çš„å»ä¸­å¿ƒåŒ–ç”Ÿæ€ç³»ç»Ÿã€‚

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "\u521b\u5efaWeb3\u6807\u51c6\u5316\u4f18\u5316\u6307\u5357\u6587\u6863", "id": "1", "priority": "high", "status": "completed"}, {"content": "\u6574\u7406\u4f18\u5316\u65b9\u6848\u7684\u6280\u672f\u7ec6\u8282", "id": "2", "priority": "high", "status": "in_progress"}, {"content": "\u6dfb\u52a0\u521d\u5b66\u8005\u4f18\u5316\u601d\u8def\u6307\u5bfc", "id": "3", "priority": "medium", "status": "pending"}, {"content": "\u63d0\u4f9b\u5b9e\u65bd\u8def\u5f84\u5efa\u8bae", "id": "4", "priority": "medium", "status": "pending"}]